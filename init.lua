vim.g.mapleader = ' ' vim.g.maplocalleader = ' ' vim.g.have_nerd_font = true vim.g.COLORSCHEME = 'kanagawa-wave' vim.g.HIGHLIGHT = true vim.g.AUTOCOMPLETE = true vim.g.TSCONTEXT = true if vim.g.neovide then vim.o.guifont = 'JetBrainsMono Nerd Font Mono:h10' vim.g.neovide_padding_top = 10 vim.g.neovide_padding_bottom = 10 vim.g.neovide_padding_left = 10 vim.g.neovide_padding_right = 10 vim.g.neovide_cursor_vfx_mode = 'pixiedust' vim.g.neovide_cursor_vfx_particle_lifetime = 1.5 vim.g.neovide_cursor_vfx_particle_density = 3.0 end vim.opt.tabstop = 4 vim.opt.expandtab = true vim.opt.laststatus = 3 vim.opt.breakindent = true vim.opt.autoindent = true vim.opt.smartindent = true vim.opt.foldcolumn = 'auto' vim.opt.signcolumn = 'auto:2' vim.opt.wrap = false vim.opt.mouse = '' vim.opt.number = false vim.opt.relativenumber = true vim.opt.showmode = false vim.opt.undofile = true vim.opt.ignorecase = true vim.opt.smartcase = true vim.opt.hlsearch = true vim.opt.incsearch = true vim.opt.updatetime = 250 vim.opt.timeoutlen = 300 vim.opt.splitright = true vim.opt.splitbelow = true vim.opt.cursorline = true vim.opt.scrolloff = 10 vim.opt.confirm = true vim.keymap.set({ 'n', 'v' }, '<Space>', '<Nop>') vim.keymap.set('o', '_', '^') vim.keymap.set('n', '<leader>x', '<cmd>!chmod +x %<cr>', { desc = 'Make this file executable', silent = true }) vim.keymap.set('n', '<C-c>', '<cmd>nohlsearch<cr>') vim.keymap.set('i', '<C-c>', '<Esc>') vim.keymap.set('n', 'Q', '<nop>') vim.keymap.set('n', 'J', 'mzJ`z') vim.keymap.set('n', '<leader>tn', '<cmd>set invrelativenumber | set invnumber<cr>', { desc = 'Toggle relative line number' }) vim.keymap.set('n', '<leader>tw', '<cmd>set invwrap<cr>', { desc = 'Toggle line wrap' }) vim.keymap.set('n', '<leader>gh', '<cmd>diffget //2<cr>', { desc = 'Get the hunk in the left' }) vim.keymap.set('n', '<leader>gl', '<cmd>diffget //3<cr>', { desc = 'Get the hunk in the right' }) vim.keymap.set('v', 'J', ":m '>+1<cr>gv=gv") vim.keymap.set('v', 'K', ":m '<-2<cr>gv=gv") vim.keymap.set('v', '<', '<gv') vim.keymap.set('v', '>', '>gv') vim.keymap.set('n', 'n', 'nzzzv') vim.keymap.set('n', 'N', 'Nzzzv') vim.keymap.set('x', '<leader>p', '"_dP') vim.keymap.set('v', '<leader>y', '"+y') vim.keymap.set('n', '<leader>Y', '"+Y') vim.keymap.set('v', '<leader>d', '"_d') vim.keymap.set('n', '<leader>q', vim.diagnostic.setloclist, { desc = 'Open diagnostic quickfix list' }) vim.api.nvim_create_autocmd('TextYankPost', { desc = 'Highlight when yoinking', callback = function() vim.highlight.on_yank() end }) vim.api.nvim_create_autocmd('VimEnter', { desc = 'Restore colorscheme', nested = true, callback = function() pcall(vim.cmd.colorscheme, vim.g.COLORSCHEME) end }) vim.api.nvim_create_autocmd('ColorScheme', { desc = 'Customize highlight groups', callback = function(params) vim.api.nvim_set_hl(0, 'TreesitterContextLineNumber', { link = 'Title' }) vim.api.nvim_set_hl(0, 'TreesitterContext', { bg = 'NONE' }) vim.api.nvim_set_hl(0, 'WinSeparator', { link = 'LineNr' }) vim.api.nvim_set_hl(0, 'IblIndent', { fg = vim.o.background == 'dark' and '#1c1d27' or '#C8C093' }) vim.api.nvim_set_hl(0, 'Normal', { bg = 'NONE' }) vim.api.nvim_set_hl(0, 'NormalNC', { link = 'Normal' }) vim.api.nvim_set_hl(0, 'NormalFloat', { link = 'Normal' }) vim.api.nvim_set_hl(0, 'SignColumn', { link = 'Normal' }) vim.api.nvim_set_hl(0, 'FoldColumn', { link = 'Normal' }) vim.api.nvim_set_hl(0, 'StatusLine', { link = 'Normal' }) vim.api.nvim_set_hl(0, 'StatusLineNC', { link = 'Normal' }) if vim.g.neovide then local paths = { vim.fn.expand('$HOME/.config/kitty/theme.conf'), vim.fn.expand('$HOME/.config/kitty/kitty.conf') } for _, kitty_conf in ipairs(paths) do for line in io.lines(kitty_conf) do line = line:match('^%s*(.-)%s*$') if not line:match('^#') then local kitty_bg = line:match('^background%s+(#%x%x%x%x%x%x)') if kitty_bg then vim.api.nvim_set_hl(0, 'Normal', { bg = kitty_bg }) return end end end end end vim.g.COLORSCHEME = params.match end }) vim.api.nvim_create_autocmd('CmdlineLeave', { desc = 'Toggle the global variables', callback = function() local cmdline = vim.fn.getcmdline() if cmdline:match('^TSToggle highlight') then vim.g.HIGHLIGHT = not vim.g.HIGHLIGHT elseif cmdline:match('^TSContext toggle') then vim.g.TSCONTEXT = not vim.g.TSCONTEXT end end }) local ns = vim.api.nvim_create_namespace('TrailingWhitespace') vim.api.nvim_create_autocmd({ 'BufWinEnter', 'TextChanged', 'InsertLeave' }, { desc = 'Hint on trailing whitespace', callback = function() local bufnr = vim.api.nvim_get_current_buf() if not vim.bo[bufnr].modifiable or vim.bo[bufnr].buftype ~= '' then vim.diagnostic.reset(ns, bufnr) return end local diagnostics = {} for lnum = 0, vim.api.nvim_buf_line_count(bufnr) - 1 do local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, false)[1] if line and line:match('%s+$') then diagnostics[#diagnostics + 1] = { lnum = lnum, col = #line:match('^(.-)%s*$'), end_col = # line, severity = vim.diagnostic.severity.HINT, message = line:match('^%s*$') and 'Line with spaces only.' or 'Line with trailing space.', source = 'custom-lint' } end end vim.diagnostic.set(ns, bufnr, diagnostics) end }) local function refresh_fugitive() vim.defer_fn( function() for _, win in ipairs(vim.api.nvim_list_wins()) do if vim.bo[vim.api.nvim_win_get_buf(win)].filetype == 'fugitive' then vim.api.nvim_win_call(win, function() pcall(function() vim.cmd.edit() end) end) end end end, 10) end vim.api.nvim_create_autocmd('BufWritePost', { desc = 'Auto-refresh vim-fugitive window', callback = function() refresh_fugitive() end }) vim.api.nvim_create_autocmd({ 'BufRead', 'BufNewFile' }, { pattern = '*.blade.php', command = 'set filetype=html' }) vim.diagnostic.config({ virtual_text = { source = 'if_many' }, severity_sort = true, jump = { float = true }, float = { border = 'rounded', source = 'if_many' }, signs = vim.g.have_nerd_font and { text = { [vim.diagnostic.severity.ERROR] = '󰅚', [vim.diagnostic.severity.WARN] = '󰀪', [vim.diagnostic.severity.INFO] = '󰋽', [vim.diagnostic.severity.HINT] = '󰌶' } } or {} }) vim.api.nvim_create_autocmd('LspAttach', { group = vim.api.nvim_create_augroup('neovim-lsp-attach', { clear = true }), callback = function(event) local set = function(keys, func, desc) vim.keymap.set('n', keys, func, { buffer = event.buf, desc = 'LSP: ' .. desc }) end local default_handler = vim.lsp.handlers['textDocument/publishDiagnostics'] vim.lsp.handlers['textDocument/publishDiagnostics'] = function(err, result, ctx, config) if result and result.diagnostics then result.diagnostics = vim.tbl_filter( function(diag) return not diag.message:match('[Tt]railing%s+[Ss]pace') and not diag.message:match('spaces%s+only') end, result.diagnostics) end return default_handler(err, result, ctx, config) end set('gd', require('telescope.builtin').lsp_definitions, 'Go to definition') set('gD', vim.lsp.buf.declaration, 'Go to declaration') set('<leader>D', require('telescope.builtin').lsp_type_definitions, 'Type definition') set('<leader>ds', require('telescope.builtin').lsp_document_symbols, 'Document symbols') set('<leader>ws', require('telescope.builtin').lsp_dynamic_workspace_symbols, 'Workspace symbols') set('K', function() vim.lsp.buf.hover({ border = 'rounded', max_width = 90 }) end, 'Hover documentation') local client = vim.lsp.get_client_by_id(event.data.client_id) if client and client:supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight) then local highlight_augroup = vim.api.nvim_create_augroup('neovim-lsp-highlight', { clear = false }) vim.api.nvim_create_autocmd({ 'CursorHold', 'CursorHoldI' }, { buffer = event.buf, group = highlight_augroup, callback = vim.lsp.buf.document_highlight }) vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, { buffer = event.buf, group = highlight_augroup, callback = vim.lsp.buf.clear_references }) vim.api.nvim_create_autocmd('LspDetach', { group = vim.api.nvim_create_augroup('neovim-lsp-detach', { clear = true }), callback = function(event2) vim.lsp.buf.clear_references() vim.api.nvim_clear_autocmds { group = 'neovim-lsp-highlight', buffer = event2.buf } end }) end if client and client:supports_method(vim.lsp.protocol.Methods.textDocument_inlayHint) then set('<leader>th', function() vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled()) end, 'Toggle inlay hints') end vim.api.nvim_create_user_command('LspStop', function() vim.lsp.stop_client(vim.lsp.get_clients()) end, { desc = 'Stop LSP client' }) vim.api.nvim_create_user_command('LspStart', function() vim.lsp.enable(vim.lsp.get_clients(), true) end, { desc = 'Start LSP client' }) end }) vim.lsp.config('*', { root_markers = { '.git' } }) local servers = { bashls = { cmd = { 'bash-language-server', 'start' }, filetypes = { 'sh', 'bash' }, settings = { bashIde = { shfmt = { caseIndent = true, spaceRedirects = true } } } }, html = { cmd = { 'vscode-html-language-server', '--stdio' }, filetypes = { 'html' }, settings = { html = { format = { indentInnerHtml = true, wrapLineLength = 0 } } } }, lua_ls = { cmd = { 'lua-language-server' }, root_markers = { '.luarc.json', '.luarc.jsonc' }, filetypes = { 'lua' }, settings = { Lua = { completion = { callSnippet = 'Replace' }, diagnostics = { disable = { 'missing-fields' } }, format = { enable = true, defaultConfig = { trailing_table_separator = 'smart', quote_style = 'single' } } } } } } for name, config in pairs(servers) do local capabilities = vim.lsp.protocol.make_client_capabilities() config.capabilities = vim.tbl_deep_extend('force', {}, capabilities, config.capabilities or {}) vim.lsp.config(name, config) end vim.lsp.enable(vim.tbl_keys(servers)) local lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim' if not vim.uv.fs_stat(lazypath) then local lazyrepo = 'https://github.com/folke/lazy.nvim.git' local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath } if vim.v.shell_error ~= 0 then error('Error cloning lazy.nvim:\n' .. out) end end vim.opt.rtp:prepend(lazypath) require('lazy').setup { ui = { border = 'rounded' }, install = { colorscheme = { vim.g.COLORSCHEME } }, spec = { { 'mason-org/mason.nvim', event = 'VeryLazy', opts = { ui = { border = 'rounded' } } }, { 'windwp/nvim-ts-autotag', event = 'InsertEnter', opts = { aliases = { ['php'] = 'html' } } }, { 'stevearc/conform.nvim', cmd = 'ConformInfo', keys = { { '<leader>f', function() if vim.bo.modifiable and vim.bo.buftype == '' then if not require('conform').format({ async = true, lsp_fallback = true }) then vim.notify('Conform: no formatter attached to this buffer', vim.log.levels.ERROR) end else vim.notify( 'Conform: buffer is not modifiable', vim.log.levels.ERROR) end end, mode = { 'n', 'v' }, desc = 'Format buffer' } }, opts = { formatters_by_ft = { c = { 'clang_format' }, php = { 'phpcbf' } }, formatters = { clang_format = { args = { '--style={BasedOnStyle: Google, IndentWidth: 4, UseTab: Never}' } }, phpcbf = { prepend_args = { '--standard=PSR12' } } } } }, { 'hrsh7th/nvim-cmp', event = 'VeryLazy', dependencies = { 'hrsh7th/cmp-nvim-lsp', 'hrsh7th/cmp-buffer', 'hrsh7th/cmp-path', 'hrsh7th/cmp-cmdline' }, opts = function() vim.keymap.set('n', '<leader>ta', function() vim.g.AUTOCOMPLETE = not vim.g.AUTOCOMPLETE require('cmp').setup({ completion = { autocomplete = vim.g.AUTOCOMPLETE and { 'InsertEnter', 'TextChanged' } } }) end, { noremap = true, silent = true, desc = 'Toggle autocompletion' }) local cmp = require('cmp') local devicons = vim.g.have_nerd_font and { Text = '', Method = '󰆧', Function = '󰊕', Constructor = '', Field = '󰇽', Variable = '󰂡', Class = '󰠱', Interface = '', Module = '', Property = '󰜢', Unit = '', Value = '󰎠', Enum = '', Keyword = '󰌋', Snippet = '', Color = '󰏘', File = '󰈙', Reference = '', Folder = '󰉋', EnumMember = '', Constant = '󰏿', Struct = '', Event = '', Operator = '󰆕', TypeParameter = '󰅲' } or {} cmp.setup { performance = { max_view_entries = 10 }, formatting = { format = function(_, vim_item) vim_item.kind = string.format('%s %s', devicons[vim_item.kind], vim_item.kind) return vim_item end }, window = { completion = cmp.config.window.bordered(), documentation = cmp.config.window.bordered() }, snippet = { expand = function( args) vim.snippet.expand(args.body) end }, completion = { autocomplete = vim.g.AUTOCOMPLETE and { 'InsertEnter', 'TextChanged' }, completeopt = 'menu,menuone,noinsert' }, mapping = cmp.mapping.preset.insert { ['<C-y>'] = cmp.mapping.confirm({ select = true, behavior = cmp.ConfirmBehavior.Replace }), ['<C-b>'] = cmp.mapping.scroll_docs(-4), ['<C-f>'] = cmp.mapping.scroll_docs(4), ['<C-l>'] = cmp.mapping(function() if vim.snippet.active({ direction = 1 }) then vim.snippet.jump(1) end end, { 'i', 's' }), ['<C-h>'] = cmp.mapping(function() if vim.snippet.active({ direction = -1 }) then vim.snippet.jump(-1) end end, { 'i', 's' }), ['<C-k>'] = function() if cmp.visible_docs() then cmp.close_docs() else cmp.open_docs() end end }, view = { docs = { auto_open = false } }, sources = cmp.config.sources({ { name = 'lazydev', group_index = 0 }, { name = 'nvim_lsp' }, { name = 'path' } }, { { name = 'buffer', option = { get_bufnrs = function() return vim.api.nvim_list_bufs() end } } }) } cmp.setup.cmdline({ '/', '?' }, { mapping = cmp.mapping.preset.cmdline(), sources = { { name = 'buffer' } } }) cmp.setup.cmdline(':', { mapping = cmp.mapping.preset.cmdline(), sources = cmp.config.sources({ { name = 'path' }, { name = 'cmdline' } }), matching = { disallow_symbol_nonprefix_matching = false } }) end }, { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate', event = 'UIEnter', opts = function() require('nvim-treesitter.configs').setup({ ensure_installed = { 'bash', 'c', 'diff', 'html', 'css', 'javascript', 'python', 'lua', 'luadoc', 'markdown', 'vim', 'vimdoc' }, auto_install = true, highlight = { enable = vim.g.HIGHLIGHT }, indent = { enable = true } }) vim.api.nvim_create_autocmd({ 'BufReadPost', 'ModeChanged' }, { desc = 'Disable treesitter on large files', callback = function() if vim.api.nvim_buf_line_count(0) > 10000 and vim.treesitter.highlighter.active[vim.api.nvim_get_current_buf()] then vim.cmd('TSDisable highlight') vim.cmd('TSDisable indent') elseif vim.g.HIGHLIGHT and not vim.treesitter.highlighter.active[vim.api.nvim_get_current_buf()] then vim.cmd('TSEnable highlight') vim.cmd('TSEnable indent') end end }) end }, { 'nvim-treesitter/nvim-treesitter-context', event = 'WinScrolled', opts = function() require( 'treesitter-context').setup({ enable = vim.g.TSCONTEXT, multiwindow = true, max_lines = 5 }) end }, { 'windwp/nvim-autopairs', event = 'InsertEnter', opts = { map_cr = true } }, { 'folke/lazydev.nvim', ft = 'lua', opts = { library = { { path = '${3rd}/luv/library', words = { 'vim%.uv' } } } } }, { 'Bilal2453/luvit-meta', lazy = true }, { 'mbbill/undotree', keys = { { '<leader>u', '<cmd>UndotreeToggle<cr>', desc = 'Toggle undotree' } } }, { 'folke/which-key.nvim', event = 'VeryLazy', opts = function() require('which-key').add { { '<leader>c', group = 'Code' }, { '<leader>r', group = 'Rename' }, { '<leader>s', group = 'Search' }, { '<leader>w', group = 'Workspace' }, { '<leader>t', group = 'Toggle' }, { '<leader>g', group = 'Git operations', mode = { 'n', 'v' } } } return { preset = 'modern' } end }, { 'echasnovski/mini.nvim', event = 'UIEnter', config = function() vim.api.nvim_create_autocmd('FileType', { pattern = { 'dashboard', 'fzf', 'help', 'lazy', 'mason', 'oil_preview' }, callback = function() vim.b.miniindentscope_disable = true end }) vim.keymap.set('n', '<leader>z', function() require('mini.misc').zoom() end, { desc = 'Toggle window zoom' }) require('mini.ai').setup { n_lines = 500 } require('mini.icons').setup() MiniIcons.mock_nvim_web_devicons() local hipatterns = require('mini.hipatterns') hipatterns.setup { highlighters = { fixme = { pattern = { ' FIXME ', ' ERROR ' }, group = 'MiniHipatternsFixme' }, hack = { pattern = { ' HACK ', ' WARNING ' }, group = 'MiniHipatternsHack' }, todo = { pattern = { ' TODO ', ' NOTE ' }, group = 'MiniHipatternsTodo' }, hex_color = hipatterns.gen_highlighter.hex_color() } } local statusline = require('mini.statusline') statusline.setup { content = { active = function() local location = '%2l:%-2v' local git = statusline.section_git({ trunc_width = 40 }) local diff = statusline.section_diff({ trunc_width = 75 }) local diagnostics = statusline.section_diagnostics({ trunc_width = 75, signs = vim.g.have_nerd_font and { ERROR = '󰅚', WARN = '󰀪', INFO = '󰋽', HINT = '󰌶' } or {} }) local filename = statusline.section_filename({ trunc_width = 140 }) local fileinfo = statusline.section_fileinfo({ trunc_width = 120 }) return statusline.combine_groups({ { hl = 'Title', strings = { location } }, { hl = 'GitSignsAdd', strings = { git, diff } }, { hl = 'Title', strings = { diagnostics } }, '%<', { hl = 'MsgArea', strings = { filename } }, '%=', { hl = 'Comment', strings = { fileinfo } } }) end } } local indentscope = require('mini.indentscope') indentscope.setup({ symbol = '│', options = { indent_at_cursor = false, try_as_border = true } }) end }, { 'christoomey/vim-tmux-navigator', keys = { { '<c-h>', '<cmd><C-U>TmuxNavigateLeft<cr>' }, { '<c-j>', '<cmd><C-U>TmuxNavigateDown<cr>' }, { '<c-k>', '<cmd><C-U>TmuxNavigateUp<cr>' }, { '<c-l>', '<cmd><C-U>TmuxNavigateRight<cr>' } } }, { 'nvim-telescope/telescope.nvim', event = 'VeryLazy', dependencies = { 'nvim-lua/plenary.nvim', { 'nvim-telescope/telescope-fzf-native.nvim', build = 'make', cond = function() return vim.fn.executable 'make' == 1 end }, { 'nvim-telescope/telescope-ui-select.nvim' } }, opts = function() local telescope = require('telescope') local builtin = require('telescope.builtin') local pickers = require('telescope.pickers') local previewers = require('telescope.previewers') local finders = require('telescope.finders') local conf = require('telescope.config').values local actions = require('telescope.actions') local action_state = require('telescope.actions.state') local set = vim.keymap.set telescope.setup { defaults = { layout_config = { height = function(_, _, max_lines) return max_lines end, width = function( _, max_columns, _) return max_columns end, preview_width = 0.50, preview_cutoff = 0.25 } }, extensions = { fzf = {}, ['ui-select'] = { require('telescope.themes').get_dropdown() } } } pcall(require('telescope').load_extension('fzf')) pcall(require('telescope').load_extension('ui-select')) set('n', '<leader>sp', function() local search_dirs = { '~/git', '~/projects/rust', '~/projects/php', '~/practice', '~/programming', '~/.config' } search_dirs = vim.tbl_map(vim.fn.expand, search_dirs) local quoted = vim.tbl_map(function(d) return vim.fn.shellescape(d) end, search_dirs) local search_cmd = 'find ' .. table.concat(quoted, ' ') .. ' -maxdepth 1 -type d' local preview_handle = io.popen(search_cmd) local results = {} if preview_handle then for dir in preview_handle:lines() do local display = dir:gsub(vim.fn.expand('~'), '~') table.insert(results, { display = display, value = dir }) end preview_handle:close() end pickers.new({}, { prompt_title = 'Search Projects', finder = finders.new_table({ results = results, entry_maker = function(entry) return { value = entry.value, display = entry.display, ordinal = entry.display } end }), sorter = conf.generic_sorter({}), previewer = previewers.new_buffer_previewer({ title = 'Directory preview', define_preview = function(self, entry) local base = entry.value local handle = io.popen(('find %q -maxdepth 1 \\( -type f -o -type d \\)'):format(base)) if not handle then return end local devicons = require('nvim-web-devicons') local files = {} for line in handle:lines() do local rel = vim.fs.basename(line) local function is_visible(path) return path ~= '' and not path:match('^%.') end if is_visible(rel) then local full_path = base .. '/' .. rel local is_dir = vim.fn.isdirectory(full_path) == 1 if is_visible(rel) then local display = is_dir and (rel .. '/') or rel local icon, hl if is_dir then icon, hl = devicons.get_icon_by_filetype('directory') if not icon then icon = '' hl = 'Directory' end else icon, hl = devicons.get_icon(rel, nil, { default = true }) end table.insert(files, { text = string.format('%s %s', icon, display), hl = hl }) end end end handle:close() table.sort(files, function(a, b) return a.text:lower() < b.text:lower() end) local lines = {} for _, f in ipairs(files) do table.insert(lines, f.text) end vim.api.nvim_buf_set_lines(self.state.bufnr, 0, -1, false, lines) local tns = vim.api.nvim_create_namespace('telescope_preview_icons') for i, f in ipairs(files) do if f.hl then vim.api.nvim_buf_set_extmark(self.state.bufnr, tns, i - 1, 0, { end_col = 1, hl_group = f.hl, hl_mode = 'combine' }) end end end }), attach_mappings = function(_, map) map('i', '<CR>', function(bufnr) local dir = action_state.get_selected_entry().value actions.close(bufnr) vim.cmd('cd ' .. vim.fn.fnameescape(dir)) vim.cmd('Oil') print('Changed directory to: ' .. dir) end) return true end }):find() end, { desc = 'Search Projects' }) set('n', '<leader>sc', function() if not pcall(function() builtin.git_commits() end) then vim.notify('Not in a Git repository', vim.log.levels.ERROR) end end, { desc = 'Search git commits' }) set('n', '<leader>sh', builtin.help_tags, { desc = 'Search help' }) set('n', '<leader>sk', builtin.keymaps, { desc = 'Search keymaps' }) set('n', '<leader>sf', builtin.find_files, { desc = 'Search files' }) set('n', '<leader>st', builtin.builtin, { desc = 'Search telescope' }) set('n', '<leader>sg', builtin.live_grep, { desc = 'Search by grep' }) set('n', '<leader>sd', builtin.diagnostics, { desc = 'Search diagnostics' }) set('n', '<leader>sr', builtin.resume, { desc = 'Search resume' }) set('n', '<leader>s.', builtin.oldfiles, { desc = 'Search recent files ("." for repeat)' }) set('n', '<leader><leader>', builtin.buffers, { desc = 'Search existing buffers' }) set('n', '<leader>/', function() builtin.current_buffer_fuzzy_find(require('telescope.themes').get_dropdown { previewer = false }) end, { desc = 'Fuzzy search current buffer' }) set('n', '<leader>s/', function() builtin.live_grep { grep_open_files = true } end, { desc = 'Search in open files' }) set('n', '<leader>sn', function() builtin.find_files { cwd = vim.fn.stdpath 'config' } end, { desc = 'Search neovim files' }) end }, { 'stevearc/oil.nvim', event = 'VimEnter', keys = { { '-', '<cmd>Oil<cr>', desc = 'Open file explorer' } }, opts = { delete_to_trash = true, default_file_explorer = true, skip_confirm_for_simple_edits = true, keymaps = { ['<C-h>'] = false, ['<C-l>'] = false, ['<M-h>'] = false } } }, { 'tpope/vim-fugitive', cmd = 'Git', keys = { { '<leader>go', function() for _, win in ipairs(vim.api.nvim_tabpage_list_wins(0)) do if vim.bo[vim.api.nvim_win_get_buf(win)].filetype == 'fugitive' then if vim.bo.filetype == 'fugitive' then return vim.api.nvim_win_close(win, true), vim.cmd('wincmd p') else return vim.api.nvim_win_close(win, true) end end end if not pcall(function() vim.cmd('Git') end) then vim.notify( 'fugitive: working directory does not belong to a Git repository', vim.log.levels.ERROR) end end, desc = 'Open/Close Git window' } } }, { 'lewis6991/gitsigns.nvim', event = 'VeryLazy', opts = { signs = { add = { text = '+' }, change = { text = '~' }, delete = { text = '_' }, topdelete = { text = '‾' }, changedelete = { text = '~' } }, sign_priority = 1000, on_attach = function( bufnr) local gitsigns = require('gitsigns') local function set(mode, l, r, opts) opts = opts or {} opts.buffer = bufnr vim.keymap.set(mode, l, r, opts) end set({ 'x', 'o' }, 'ih', ':Gitsigns select_hunk<cr>', { silent = true }) set('v', '<leader>gs', function() gitsigns.stage_hunk({ vim.fn.line('.'), vim.fn.line('v') }) refresh_fugitive() end, { desc = 'Stage hunk' }) set('v', '<leader>gr', function() gitsigns.reset_hunk({ vim.fn.line('.'), vim.fn.line('v') }) end, { desc = 'Reset hunk' }) set('n', ']h', function() gitsigns.nav_hunk('next') end, { desc = 'Next hunk' }) set('n', '[h', function() gitsigns.nav_hunk('prev') end, { desc = 'Previous hunk' }) set('n', ']H', function() gitsigns.nav_hunk('next', { target = 'staged' }) end, { desc = 'Next hunk' }) set('n', '[H', function() gitsigns.nav_hunk('prev', { target = 'staged' }) end, { desc = 'Previous hunk' }) set('n', '<leader>gs', function() gitsigns.stage_hunk() refresh_fugitive() end, { desc = 'Stage/Unstage hunk' }) set('n', '<leader>gS', function() gitsigns.stage_buffer() refresh_fugitive() end, { desc = 'Stage all hunks' }) set('n', '<leader>gU', function() gitsigns.reset_buffer_index() refresh_fugitive() end, { desc = 'Unstage all hunks' }) set('n', '<leader>gr', function() gitsigns.reset_hunk() end, { desc = 'Reset hunk' }) set('n', '<leader>gR', function() gitsigns.reset_buffer() end, { desc = 'Reset all hunks' }) set('n', '<leader>gD', function() gitsigns.diffthis('@') end, { desc = 'Diff against last commit' }) set('n', '<leader>gp', gitsigns.preview_hunk, { desc = 'Preview hunk' }) set('n', '<leader>gb', gitsigns.blame_line, { desc = 'Blame line' }) set('n', '<leader>tb', gitsigns.toggle_current_line_blame, { desc = 'Toggle line blame' }) set('n', '<leader>td', gitsigns.preview_hunk_inline, { desc = 'Toggle deleted/changed hunks' }) set('n', '<leader>gd', function() if vim.wo.diff then vim.cmd('diffoff!') vim.cmd('wincmd p') vim.cmd('q') vim.cmd('wincmd p') else gitsigns.diffthis() end end, { desc = 'Toggle Diff against index' }) end } }, { 'mfussenegger/nvim-dap', lazy = true, keys = { { '<F7>', function() local dapui = require('dapui') dapui.toggle() local is_open = false for _, win in ipairs(vim.api.nvim_list_wins()) do local bufname = vim.api.nvim_buf_get_name(vim.api.nvim_win_get_buf(win)) if bufname:match('DAP') then is_open = true break end end vim.opt.laststatus = is_open and 2 or 3 end, desc = 'Debug: Toggle DAP UI' }, { '<F5>', function() require('dap').continue() end, desc = 'Debug: Start/Continue' }, { '<F1>', function() require('dap').step_into() end, desc = 'Debug: Step Into' }, { '<F2>', function() require('dap').step_over() end, desc = 'Debug: Step Over' }, { '<F3>', function() require('dap').step_out() end, desc = 'Debug: Step Out' }, { '<leader>b', function() require('dap').toggle_breakpoint() end, desc = 'Debug: Toggle Breakpoint' }, { '<leader>B', function() require('dap').set_breakpoint(vim.fn.input 'Breakpoint condition: ') end, desc = 'Debug: Set Breakpoint' } }, dependencies = { 'rcarriga/nvim-dap-ui', 'nvim-neotest/nvim-nio', { 'jay-babu/mason-nvim-dap.nvim', opts = { automatic_installation = true, handlers = {}, ensure_installed = { 'codelldb' } } } }, config = function() local dap = require('dap') local dapui = require('dapui') dapui.setup() dap.adapters.codelldb = { type = 'executable', command = 'codelldb' } dap.configurations.c = { { name = 'Launch file', type = 'codelldb', request = 'launch', program = function() return vim .fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file') end, cwd = '${workspaceFolder}', stopOnEntry = false } } dap.configurations.rust = dap.configurations.c dap.listeners.after.event_initialized['dapui_config'] = dapui.open dap.listeners.before.event_terminated['dapui_config'] = dapui.close dap.listeners.before.event_exited['dapui_config'] = dapui.close end }, { 'nvimdev/dashboard-nvim', event = 'UIEnter', opts = function() local logo = ' ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠘⢿⣦⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⣿⡎⠉⠉⠛⠻⣶⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⣿⠃⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⢻⣁⠀⠀⠀⠀⠈⢻⡆⠀⠠⣴⣤⣀⣠⣤⠀⢠⣾⡇⠀⢶⣴⠶⢿⠾⢷⣄⢿⡆⠀⠀⢹⡏⠀⠀⠀⠀⠀⢴⣶⡆⠀⠀⠰⣾⠟⠁⠀⠀⠀⠀⠀⣦⣄⣀⣿⣃⣀⣀⠀⠀⠀⠀⠀⠀\n ⠀⢸⡇⠀⢀⣀⡀⠀⢸⣿⡄⠀⣵⠀⠀⠈⠉⠀⢸⠏⢷⠀⠀⠀⠀⢸⡄⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⠀⠀⠀⢸⡿⠻⣆⠀⠀⣿⠀⠀⣠⡶⢶⣄⠀⠉⠉⠉⣿⠏⠉⠉⣶⣦⣤⡶⠶⣂\n ⠀⠀⣇⠀⠘⠛⠁⠀⠈⣿⣧⠀⣿⣠⣤⡤⣄⠀⣸⠀⣸⣆⣄⠀⠀⢸⡇⠀⠐⠚⡟⠋⠉⣽⠋⠀⠀⠀⠀⠀⢸⡇⠀⠘⣧⡀⢸⠀⣴⢋⣠⣄⢹⣦⠀⠀⣠⣿⠀⠀⠀⣿⡇⠀⠀⠀⠀\n ⠀⠀⣿⠀⠀⠀⠀⠀⢀⣿⠇⠀⣿⠀⠉⠉⠋⠀⣿⠿⠿⢿⡏⠀⠀⢸⡇⠀⠀⠀⡇⠀⠀⣿⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠹⣿⣸⡆⣿⠈⠙⠋⠀⣿⠀⠀⢹⡇⠀⠀⠀⢹⣷⣶⣤⣴⠀\n ⠀⠀⣿⠀⠀⠀⠀⣀⣼⠃⠀⢰⣧⣤⣤⣤⡄⢀⣿⠀⠀⢸⣧⠀⠀⣘⣿⠀⠀⠀⣿⠀⠀⢿⡀⠀⠀⠀⠀⠀⠸⣧⠀⠀⠀⠙⣿⡇⠹⢦⣤⣤⣾⠋⠀⠠⠼⠷⠀⠀⠀⢸⣿⠀⠀⠀⠀\n ⠀⢀⣿⣀⣤⣶⠿⠋⠀⠀⣀⣤⣶⣿⣿⣿⣷⣶⣶⣶⣤⡀⠀⠀⠀⠈⠙⠃⠀⠚⠛⠀⠀⠘⠉⠀⠀⠀⠀⠀⠚⠉⠀⠀⠀⣠⣬⣿⣶⣶⣾⣿⣿⣿⡿⠿⣶⣦⣤⡀⠀⣼⣿⣤⣤⣤⣄\n ⠀⢸⣿⠛⠁⠀⠀⣠⣶⠟⠛⢻⡟⠀⠈⢹⣿⠉⢹⣿⡿⣿⣦⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣿⣿⡿⢿⣿⡟⠁⢻⣿⠁⠀⠀⠀⣿⠉⠙⠳⣤⡀⠀⠀⠀⠀\n ⠀⠀⠀⠀⣠⠶⠋⠁⠀⠀⠀⠈⡇⠀⠀⠘⣿⠀⠀⢸⡇⠈⠻⣿⣿⣿⣷⣦⣤⣤⣄⡀⠀⠀⢀⡀⡀⡀⠀⣴⣿⠿⣿⣿⠀⡿⠀⢸⡏⠀⠀⢸⠃⠀⠀⠀⠀⠃⠀⠀⠀⠈⠉⢳⣄⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠈⢿⠀⠀⠘⡟⠀⠀⠹⣿⢿⣿⣤⣀⣈⣿⣿⣿⣥⡾⠛⠉⠀⢸⡏⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠀⠀⠀⠇⠀⠀⠀⠻⠀⠀⣼⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠘⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣺⣿⢻⣿⣿⣿⠟⢻⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠇⣿⣿⣿⣿⣇⠘⢿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡏⣸⣿⣿⠿⣿⣿⠀⢻⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢙⡇⢿⣿⡇⠀⢻⣿⡄⢸⡗⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣟⣄⣿⡅⠀⠠⣿⣧⢾⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⣿⡇⠀⣼⣿⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠀⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⢠⡿⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⢸⣿⡄⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣇⡼⠏⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n ' local opts = { theme = 'doom', hide = { statusline = true }, config = { header = vim.split(string.rep('\n', 15) .. logo, '\n'), center = { { action = '', desc = '', icon = '' } }, footer = {} } } return opts end }, { 'OXY2DEV/markview.nvim', ft = 'markdown', keys = { { '<leader>tm', '<cmd>Markview<cr>', desc = 'Toggle markdown view' } } }, { 'rebelot/kanagawa.nvim', event = 'VeryLazy', opts = { transparent = true, colors = { palette = { carpYellow = '#C8C093', dragonYellow = '#a99c8b' }, theme = { all = { ui = { bg_gutter = 'none' } } } }, overrides = function() return { NormalFloat = { bg = 'NONE' }, FloatBorder = { bg = 'NONE' }, FloatTitle = { bg = 'NONE' }, TelescopePromptBorder = { link = 'FloatBorder' }, TelescopeResultsBorder = { link = 'FloatBorder' }, TelescopePreviewBorder = { link = 'FloatBorder' } } end } }, { 'lukas-reineke/indent-blankline.nvim', event = 'UIEnter', main = 'ibl', opts = { indent = { char = '│' }, scope = { enabled = false }, exclude = { filetypes = { 'lazy', 'dashboard' } } } } } } -- The forbidden neovim config ʕっ-ᴥ•ʔ︻デ══━一 vim:noma:bt=nowrite
